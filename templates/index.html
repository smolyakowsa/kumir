<!DOCTYPE html>
<html>
<head>
    <title>Кумир симулятор</title>
    <style>
        /* Стили остаются прежними */
        body { margin: 0; display: flex; height: 100vh; }
        .code-container, .field-container { padding: 20px; }
        .code-container { width: 40%; background: #f0f0f0; }
        #code { width: 100%; height: 90%; font-family: monospace; }
        #field { position: relative; background: #fff; }
        .cell {
            position: absolute; width: 40px; height: 40px;
            border: 1px solid #ddd; box-sizing: border-box;
        }
        .robot { background-color: #ff4444 !important; }
        .painted { background-color: #aaffaa; }
        .wall { position: absolute; background-color: #000; }
        .vertical { width: 4px; height: 40px; }
        .horizontal { width: 40px; height: 4px; }
    </style>
</head>
<body>
    <div class="code-container">
        <textarea id="code">алг Движение
нач
  нц пока справа свободно
    вправо
  кц
  если снизу свободно то
    вниз
    закрасить
  все
кон</textarea>
        <div class="controls">
            <button onclick="ExecutionControl.start()">Старт</button>
            <button onclick="ExecutionControl.pause()">Пауза</button>
            <button onclick="ExecutionControl.reset()">Сброс</button>
        </div>
    </div>

    <div class="field-container">
        <div id="field"></div>
    </div>

<script>
class ExecutionError extends Error {
    constructor(message, line) {
        super(`[Ошибка] Строка ${line}: ${message}`);
        this.name = "ExecutionError";
    }
}

const FieldState = new Proxy({
    width: 10,
    height: 10,
    robot: { x: 0, y: 0 },
    walls: new Set(),
    obstacles: new Set(),
    painted: new Set()
}, {
    set(target, prop, value) {
        if (prop === 'robot') {
            UpdateManager.updateRobotPosition(value);
        }
        return Reflect.set(...arguments);
    }
});

const UpdateManager = {
    updateRobotPosition(pos) {
        document.querySelectorAll('.robot').forEach(c => c.classList.remove('robot'));
        const cell = document.querySelector(`.cell[data-x="${pos.x}"][data-y="${pos.y}"]`);
        cell?.classList.add('robot');
    },

    updatePaintedCells() {
        document.querySelectorAll('.cell').forEach(cell => {
            const key = `${cell.dataset.x},${cell.dataset.y}`;
            cell.classList.toggle('painted', FieldState.painted.has(key));
        });
    }
};

const FieldBuilder = {
    init() {
        this.createField();
        this.addEventListeners();
    },

    createField() {
        const fragment = document.createDocumentFragment();
        for (let y = 0; y < FieldState.height; y++) {
            for (let x = 0; x < FieldState.width; x++) {
                const cell = this.createCell(x, y);
                fragment.appendChild(cell);
                this.addWalls(fragment, x, y);
            }
        }
        document.getElementById('field').appendChild(fragment);
    },

    createCell(x, y) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.x = x;
        cell.dataset.y = y;
        cell.style.left = `${x * 42}px`;
        cell.style.top = `${y * 42}px`;
        cell.addEventListener('click', e => this.handleCellClick(x, y, e));
        return cell;
    },

    addWalls(fragment, x, y) {
        if (x < FieldState.width - 1) this.addWall(fragment, x, y, x+1, y, 'vertical');
        if (y < FieldState.height - 1) this.addWall(fragment, x, y, x, y+1, 'horizontal');
    },

    addWall(fragment, x1, y1, x2, y2, type) {
        const wall = document.createElement('div');
        wall.className = `wall ${type}`;
        wall.style.left = `${type === 'vertical' ? x2 * 42 - 2 : x1 * 42}px`;
        wall.style.top = `${type === 'horizontal' ? y2 * 42 - 2 : y1 * 42}px`;
        wall.addEventListener('click', () => this.toggleWall(x1, y1, x2, y2));
        fragment.appendChild(wall);
    },

    handleCellClick(x, y, e) {
        if (e.shiftKey) this.toggleObstacle(x, y);
    },

    toggleObstacle(x, y) {
        const key = `${x},${y}`;
        FieldState.obstacles.has(key)
            ? FieldState.obstacles.delete(key)
            : FieldState.obstacles.add(key);
        document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`)
            ?.classList.toggle('obstacle');
    },

    toggleWall(x1, y1, x2, y2) {
        const key = `${x1},${y1},${x2},${y2}`;
        const reverseKey = `${x2},${y2},${x1},${y1}`;
        FieldState.walls.has(key) || FieldState.walls.has(reverseKey)
            ? FieldState.walls.delete(key) || FieldState.walls.delete(reverseKey)
            : FieldState.walls.add(key);
        this.updateWalls();
    },

    updateWalls() {
        document.querySelectorAll('.wall').forEach(wall => {
            const coords = wall.style.left + wall.style.top;
            const key = this.getWallKey(wall);
            wall.style.backgroundColor =
                FieldState.walls.has(key) ? '#000' : 'transparent';
        });
    },

    getWallKey(wall) {
        const x = parseInt(wall.style.left) / 42;
        const y = parseInt(wall.style.top) / 42;
        return wall.classList.contains('vertical')
            ? `${Math.floor(x)},${y},${Math.ceil(x)},${y}`
            : `${x},${Math.floor(y)},${x},${Math.ceil(y)}`;
    }
};

const CodeProcessor = {
    validate(code) {
        const errors = [];
        if (!code.includes('нач') || !code.includes('кон')) {
            errors.push('Отсутствуют обязательные ключевые слова нач/кон');
        }
        return errors;
    },

    sanitize(code) {
        return code
            .replace(/[^а-яё\s\n]/gi, '')
            .split('\n')
            .map(line => line.trim().toLowerCase())
            .filter(line => line.length > 0);
    }
};

const ExecutionControl = {
    isRunning: false,
    currentPromise: null,

    async start() {
        if (this.isRunning) return;
        this.isRunning = true;

        try {
            const code = document.getElementById('code').value;
            const commands = CodeProcessor.sanitize(code);
            const errors = CodeProcessor.validate(code);

            if (errors.length > 0) {
                throw new ExecutionError(errors.join('\n'), 0);
            }

            await this.executeCommands(commands);
        } catch (e) {
            console.error(e);
            alert(e.message);
        } finally {
            this.reset();
        }
    },

    async executeCommands(commands) {
        let pc = 0;
        const stack = [];

        while (pc < commands.length && this.isRunning) {
            const cmd = commands[pc];
            try {
                switch(true) {
                    case cmd.startsWith('нц пока'):
                        pc = await this.handleLoopStart(commands, pc);
                        break;
                    case cmd === 'кц':
                        pc = this.handleLoopEnd(commands, pc, stack);
                        break;
                    case cmd.startsWith('если'):
                        pc = this.handleConditionStart(commands, pc);
                        break;
                    case cmd === 'все':
                        pc++;
                        break;
                    default:
                        await this.executeCommand(cmd, pc);
                        pc++;
                }
                await new Promise(resolve => setTimeout(resolve, 300));
            } catch (e) {
                throw new ExecutionError(e.message, pc + 1);
            }
        }
    },

    async executeCommand(cmd, line) {
        const directions = {
            'вверх': [0, -1],
            'вниз': [0, 1],
            'влево': [-1, 0],
            'вправо': [1, 0]
        };

        if (directions[cmd]) {
            await this.moveRobot(directions[cmd], line);
        } else if (cmd === 'закрасить') {
            FieldState.painted.add(`${FieldState.robot.x},${FieldState.robot.y}`);
            UpdateManager.updatePaintedCells();
        }
    },

    async moveRobot([dx, dy], line) {
        const newX = FieldState.robot.x + dx;
        const newY = FieldState.robot.y + dy;
        const wallKey = `${FieldState.robot.x},${FieldState.robot.y},${newX},${newY}`;

        if (FieldState.walls.has(wallKey)) {
            throw new Error('На пути стена');
        }

        if (newX < 0 || newX >= FieldState.width ||
            newY < 0 || newY >= FieldState.height) {
            throw new Error('Выход за границы поля');
        }

        if (FieldState.obstacles.has(`${newX},${newY}`)) {
            throw new Error('Препятствие на пути');
        }

        FieldState.robot = { x: newX, y: newY };
        await this.animateMovement();
    },

    async animateMovement() {
        const robotElem = document.querySelector('.robot');
        if (!robotElem) return;

        robotElem.style.transition = 'all 0.3s ease';
        robotElem.style.left = `${FieldState.robot.x * 42}px`;
        robotElem.style.top = `${FieldState.robot.y * 42}px`;

        await new Promise(resolve =>
            robotElem.addEventListener('transitionend', resolve, { once: true })
        );
    },

    reset() {
        this.isRunning = false;
        FieldState.robot = { x: 0, y: 0 };
        FieldState.painted.clear();
        UpdateManager.updatePaintedCells();
    },

    pause() {
        this.isRunning = false;
    }
};

// Инициализация при загрузке
window.addEventListener('load', () => {
    FieldBuilder.init();
    FieldBuilder.updateWalls();
});
</script>
</body>
</html>